package at.logic.gapt.expr

import at.logic.gapt.expr.fol.FOLPosition._
import at.logic.gapt.expr.fol.FOLPosition
import at.logic.gapt.expr.hol.HOLPosition

trait HOLFormula extends LambdaExpression {
  override def replace( pos: HOLPosition, exp: LambdaExpression ) = HOLPosition.replace( this, pos, exp )
}
trait HOLAtom extends HOLFormula with HOLPartialAtom {
  private[expr] override def numberOfArguments: Int = 0
}

trait LogicalConstant extends Const

trait FOLExpression extends LambdaExpression {
  /**
   * Retrieves this expression's subexpression at a given position.
   *
   * @param pos The position to be retrieved.
   * @return The subexpression at pos.
   */
  def apply( pos: FOLPosition ): FOLExpression = get( pos ) match {
    case Some( f ) => f
    case None      => throw new Exception( "Position " + pos + " does not exist in expression " + this + "." )
  }

  /**
   * Retrieves this expression's subexpression at a given position, if there is one.
   *
   * @param pos The position to be retrieved.
   * @return If there is a subexpression at that position, return Some(that expression). Otherwise None.
   */
  def get( pos: FOLPosition ): Option[FOLExpression] =
    FOLPosition.toHOLPositionOption( this )( pos ).flatMap( get ).asInstanceOf[Option[FOLExpression]]

  def replace( pos: FOLPosition, replacement: FOLExpression ): FOLExpression =
    FOLPosition.replace( this, pos, replacement )

  /**
   * Tests whether this expression has a subexpression at a given position.
   *
   * @param pos The position to be tested.
   * @return Whether this(pos) is defined.
   */
  def isDefinedAt( pos: FOLPosition ): Boolean = get( pos ).isDefined

  /**
   * Finds all HOL positions of a subexpression in this expression.
   *
   * @param exp The subexpression to be found.
   * @return A list containing all positions where exp occurs.
   */
  def find( exp: FOLExpression ): List[FOLPosition] = getPositions( this, _ == exp )

}

trait FOLPartialAtom extends HOLPartialAtom
trait FOLAtomConst extends HOLAtomConst with FOLPartialAtom {
  def apply( that: FOLTerm* )( implicit dummyImplicit: DummyImplicit ) = App( this, that ).asInstanceOf[FOLAtom]
}

private[expr] trait FOLPartialFormula extends LambdaExpression {
  private[expr] def numberOfArguments: Int
}

trait FOLPartialTerm extends LambdaExpression {
  private[expr] def numberOfArguments: Int
}
trait FOLFunctionConst extends Const with FOLPartialTerm {
  def apply( that: FOLTerm* )( implicit dummyImplicit: DummyImplicit ) = App( this, that ).asInstanceOf[FOLTerm]
}

trait HOLPartialAtom extends LambdaExpression {
  private[expr] def numberOfArguments: Int

  def apply( that: LambdaExpression* )( implicit dummyImplicit: DummyImplicit ) = App( this, that ).asInstanceOf[HOLAtom]
}
trait HOLAtomConst extends Const with HOLPartialAtom

trait FOLTerm extends FOLPartialTerm with FOLExpression {
  private[expr] override val numberOfArguments = 0
}
trait FOLVar extends Var with FOLTerm
trait FOLConst extends Const with FOLTerm with FOLFunctionConst
trait FOLFormula extends FOLPartialFormula with HOLFormula with FOLExpression {
  private[expr] override val numberOfArguments = 0

  def &( that: FOLFormula ): FOLFormula = And( this, that )
  def |( that: FOLFormula ): FOLFormula = Or( this, that )
  override def unary_- : FOLFormula = Neg( this )
  def -->( that: FOLFormula ): FOLFormula = Imp( this, that )
  def <->( that: FOLFormula ) = And( Imp( this, that ), Imp( that, this ) )
}
trait FOLAtom extends FOLPartialAtom with HOLAtom with FOLFormula {
  private[expr] override val numberOfArguments: Int = 0
}

private[expr] trait FOLFormulaWithBoundVar extends LambdaExpression
trait FOLQuantifier extends LogicalConstant

private[expr] trait PropPartialFormula extends FOLPartialFormula
trait PropFormula extends PropPartialFormula with FOLFormula
trait PropConnective extends LogicalConstant with PropPartialFormula
trait PropAtom extends Const with PropFormula with FOLAtom with FOLAtomConst

/**
 * Determine the correct traits for a given lambda expression.
 *
 * We assign to each lambda expression a set of traits it is supposed to have.  These traits are generated by a
 * (non-deterministic) tree automaton with rules such as App(NegC(), FOLFormula) -> FOLFormula.
 *
 * This object contains private classes for each of the resulting determinized states.  We could use anonymous types as
 * well, i.e. Var with FOLVar instead of Var_with_FOLVar, but these would show up in the debugger as
 * determineTraits$$anon$27, which is not particularly readable.
 */
private[expr] object determineTraits {
  private class Var_with_FOLVar( s: SymbolA, t: Ty ) extends Var( s, t ) with FOLVar
  private class Var_with_HOLFormula( s: SymbolA, t: Ty ) extends Var( s, t ) with HOLFormula
  private class Var_with_HOLAtom( s: SymbolA, t: Ty ) extends Var( s, t ) with HOLAtom
  private class Var_with_HOLPartialAtom( s: SymbolA, t: Ty, override val numberOfArguments: Int ) extends Var( s, t ) with HOLPartialAtom

  def forVar( sym: SymbolA, exptype: Ty ): Var = exptype match {
    case Ti                     => new Var_with_FOLVar( sym, exptype )
    case To                     => new Var_with_HOLAtom( sym, exptype )
    case FunctionType( To, ts ) => new Var_with_HOLPartialAtom( sym, exptype, ts.length )
    case _                      => new Var( sym, exptype )
  }

  private class Const_with_FOLQuantifier( s: SymbolA, t: Ty ) extends Const( s, t ) with FOLQuantifier
  private class Const_with_LogicalConstant( s: SymbolA, t: Ty ) extends Const( s, t ) with LogicalConstant
  private class Const_with_PropConnective_with_PropFormula( s: SymbolA, t: Ty ) extends Const( s, t ) with PropConnective with PropFormula
  private class Const_with_FOLConst( s: SymbolA, t: Ty ) extends Const( s, t ) with FOLConst
  private class Const_with_PropAtom( s: SymbolA, t: Ty ) extends Const( s, t ) with PropAtom
  private class Const_with_PropConnective( s: SymbolA, t: Ty, override val numberOfArguments: Int ) extends Const( s, t ) with PropConnective
  private class Const_with_PropPartialFormula( s: SymbolA, t: Ty, override val numberOfArguments: Int ) extends Const( s, t ) with PropPartialFormula
  private class Const_with_FOLFunctionConst( s: SymbolA, t: Ty, override val numberOfArguments: Int ) extends Const( s, t ) with FOLFunctionConst
  private class Const_with_FOLAtomConst( s: SymbolA, t: Ty, override val numberOfArguments: Int ) extends Const( s, t ) with FOLAtomConst
  private class Const_with_HOLAtomConst( s: SymbolA, t: Ty, override val numberOfArguments: Int ) extends Const( s, t ) with HOLAtomConst
  def forConst( sym: SymbolA, exptype: Ty ): Const = ( sym, exptype ) match {
    case ForallC( Ti ) | ExistsC( Ti ) => new Const_with_FOLQuantifier( sym, exptype )
    case ForallC( _ ) | ExistsC( _ )   => new Const_with_LogicalConstant( sym, exptype )
    case AndC() | OrC() | ImpC()       => new Const_with_PropConnective( sym, exptype, 2 )
    case NegC()                        => new Const_with_PropConnective( sym, exptype, 1 )
    case TopC() | BottomC()            => new Const_with_PropConnective_with_PropFormula( sym, exptype )
    case ( _, Ti )                     => new Const_with_FOLConst( sym, exptype )
    case ( _, To )                     => new Const_with_PropAtom( sym, exptype )
    case ( _, FOLHeadType( Ti, n ) )   => new Const_with_FOLFunctionConst( sym, exptype, n )
    case ( _, FOLHeadType( To, n ) )   => new Const_with_FOLAtomConst( sym, exptype, n )
    case ( _, FunctionType( To, ts ) ) => new Const_with_HOLAtomConst( sym, exptype, ts.length )
    case _                             => new Const( sym, exptype )
  }

  private class App_with_PropFormula( f: LambdaExpression, a: LambdaExpression ) extends App( f, a ) with PropFormula
  private class App_with_FOLTerm( f: LambdaExpression, a: LambdaExpression ) extends App( f, a ) with FOLTerm
  private class App_with_FOLAtom( f: LambdaExpression, a: LambdaExpression ) extends App( f, a ) with FOLAtom
  private class App_with_FOLFormula( f: LambdaExpression, a: LambdaExpression ) extends App( f, a ) with FOLFormula
  private class App_with_HOLAtom( f: LambdaExpression, a: LambdaExpression ) extends App( f, a ) with HOLAtom
  private class App_with_HOLFormula( f: LambdaExpression, a: LambdaExpression ) extends App( f, a ) with HOLFormula
  private class App_with_FOLPartialTerm( f: LambdaExpression, a: LambdaExpression, override val numberOfArguments: Int ) extends App( f, a ) with FOLPartialTerm
  private class App_with_FOLPartialAtom( f: LambdaExpression, a: LambdaExpression, override val numberOfArguments: Int ) extends App( f, a ) with FOLPartialAtom
  private class App_with_FOLPartialFormula( f: LambdaExpression, a: LambdaExpression, override val numberOfArguments: Int ) extends App( f, a ) with FOLPartialFormula
  private class App_with_PropPartialFormula( f: LambdaExpression, a: LambdaExpression, override val numberOfArguments: Int ) extends App( f, a ) with PropPartialFormula
  private class App_with_HOLPartialAtom( f: LambdaExpression, a: LambdaExpression, override val numberOfArguments: Int ) extends App( f, a ) with HOLPartialAtom
  def forApp( f: LambdaExpression, a: LambdaExpression ): App = ( f, a ) match {
    case ( f: PropPartialFormula, a: PropFormula ) => f.numberOfArguments match {
      case 1 => new App_with_PropFormula( f, a )
      case n => new App_with_PropPartialFormula( f, a, n - 1 )
    }

    case ( f: FOLPartialTerm, a: FOLTerm ) => f.numberOfArguments match {
      case 1 => new App_with_FOLTerm( f, a )
      case n => new App_with_FOLPartialTerm( f, a, n - 1 )
    }

    case ( f: FOLPartialAtom, a: FOLTerm ) => f.numberOfArguments match {
      case 1 => new App_with_FOLAtom( f, a )
      case n => new App_with_FOLPartialAtom( f, a, n - 1 )
    }

    case ( f: FOLPartialFormula, a: FOLFormula ) => f.numberOfArguments match {
      case 1 => new App_with_FOLFormula( f, a )
      case n => new App_with_FOLPartialFormula( f, a, n - 1 )
    }

    case ( f: FOLQuantifier, _ ) => a match {
      case a: FOLFormulaWithBoundVar => new App_with_FOLFormula( f, a )
      case _                         => new App_with_HOLFormula( f, a )
    }

    case ( f: HOLPartialAtom, _ ) => f.numberOfArguments match {
      case 1 => new App_with_HOLAtom( f, a )
      case n => new App_with_HOLPartialAtom( f, a, n - 1 )
    }

    case _ => f.exptype match {
      case `->`( _, To ) => new App_with_HOLFormula( f, a )
      case _             => new App( f, a )
    }
  }

  private class Abs_with_FOLFormulaWithBoundVar( v: Var, t: LambdaExpression ) extends Abs( v, t ) with FOLFormulaWithBoundVar
  def forAbs( v: Var, t: LambdaExpression ): Abs = ( v.exptype, t ) match {
    case ( Ti, t: FOLFormula ) => new Abs_with_FOLFormulaWithBoundVar( v, t )
    case _                     => new Abs( v, t )
  }
}

object FOLVar {
  def apply( sym: String ): FOLVar = Var( sym, Ti ).asInstanceOf[FOLVar]
  def unapply( e: FOLVar ) = Some( e.name )
}

object FOLConst {
  def apply( sym: String ): FOLConst = FOLFunction( sym ).asInstanceOf[FOLConst]
  def unapply( e: FOLConst ) = Some( e.name )
}

private[expr] class FOLHead( ret: Ty ) {
  def apply( sym: String, arity: Int ): Const =
    Const( sym, FOLHeadType( ret, arity ) )
  def unapply( e: LambdaExpression ): Option[( String, Int )] = e match {
    case NonLogicalConstant( sym, FOLHeadType( `ret`, arity ) ) => Some( ( sym, arity ) )
    case _ => None
  }
}

object FOLAtomConst extends FOLHead( To ) {
  override def apply( sym: String, arity: Int ): FOLAtomConst =
    super.apply( sym, arity ).asInstanceOf[FOLAtomConst]
}
object FOLFunctionConst extends FOLHead( Ti ) {
  override def apply( sym: String, arity: Int ): FOLFunctionConst =
    super.apply( sym, arity ).asInstanceOf[FOLFunctionConst]
}

object FOLAtom {
  def apply( sym: String, args: FOLTerm* )( implicit dummyImplicit: DummyImplicit ): FOLAtom = FOLAtom( sym, args )
  def apply( sym: String, args: Seq[FOLTerm] ): FOLAtom =
    Apps( FOLAtomConst( sym, args.size ), args ).asInstanceOf[FOLAtom]

  def unapply( e: FOLAtom ): Option[( String, List[FOLTerm] )] = e match {
    case Apps( FOLAtomConst( sym, _ ), args ) if e.isInstanceOf[FOLAtom] =>
      Some( ( sym, args.asInstanceOf[List[FOLTerm]] ) )
    case _ => None
  }
}

object HOLAtomConst {
  def apply( name: String, argTypes: Ty* ): HOLAtomConst =
    Const( name, FunctionType( To, argTypes ) ).asInstanceOf[HOLAtomConst]

  def unapply( e: Const with HOLPartialAtom ): Option[( String, Seq[Ty] )] = e match {
    case Const( name, FunctionType( To, argTypes ) ) => Some( name -> argTypes )
  }
}

object HOLAtom {
  def apply( head: LambdaExpression, args: LambdaExpression* ): HOLAtom =
    apply( head, args toList )
  def apply( head: LambdaExpression, args: List[LambdaExpression] ): HOLAtom =
    Apps( head, args ).asInstanceOf[HOLAtom]
  def unapply( e: HOLAtom ): Option[( LambdaExpression, List[LambdaExpression] )] = e match {
    case Apps( head @ ( NonLogicalConstant( _, _ ) | Var( _, _ ) ), args ) if e.exptype == To => Some( head, args )
    case _ => None
  }
}

